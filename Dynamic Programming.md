# Dynamic Programming

동적계획법으로 큰 문제를 작게 나누고 같은 문제라면 한번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법

> 특정한 문제를 완전탐색 알고리즘으로 접근했을 때, 시간이 매우 오래걸린다면 다이나믹프로그래밍을 적용할 수 있는지 해결하고자하는 부분 문제들의 중복 여부를 확인
> 
- `탑다운(재귀)`
    
    메모제이션 기법으로 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법, 큰 문제를 해결하기 위해 작은 문제를 호출
    
    ```python
    # 피보나치 수열
    
    # 메모제이션하기 위한 리스트 초기화
    d = [0]*100
    
    # 탑다운 다이나믹 프로그래밍
    def fibo(x):
    	if x == 1 or x == 2:
    		return 1
    	# 이미 계산한 문제라면
    	if d[x] != 0:
    		return d[x]
    	# 아직 계산하지 않은 문제라면
    	d[x] = fibo(x-1) + fivo(x-2)
    	return d[x]
    print(fibo(99))
    
    ```
    
- `보텀업(반복문)`
    
    작은 문제부터 차근차근 답을 도출, 다이나믹프로그래밍의 전형적인 형태
    
    ```python
    # 피보나치 수열
    
    # 앞서 계산된 결과를 저장하기 위한 DP테이블 초기화
    d = [0]*100
    
    d[1] = 1
    d[2] = 1
    n = 99
    
    # 보텀업 다이나믹 프로그래밍
    for i in range(3, n+1):
    	d[i] = d[i-1] + d[i-2]
    
    print(d[n])
    ```
    
- **1로만들기**
    
    사용할수 있는 4가지 연산을 최소로 사용해서 1을 만들고 횟수의 최솟값을 출력하시오
    
    1. 5로 나누어떨어지면 5로 나누기
    2. 3으로 나누어떨어지면 3으로 나누기
    3. 2로 나누어떨어지면 2로 나누기
    4. 1 빼기
    
    <입력 조건>
    
    첫째줄 : 정수 X (1~30,000)
    
    ```python
    X = int(input())
    dp = [0]*(X+1)
    for n in range(2,X+1):
        dp[n] = dp[n-1]+1 # -1하는 방법
        if n%5 == 0:
            dp[n] = min(dp[n],dp[n//5]+1)
        if n%3 == 0:
            dp[n] = min(dp[n],dp[n//3]+1)
        if n%2 == 0:
            dp[n] = min(dp[n],dp[n//2]+1)
    		# 각각 -1, 5로나누기, 3으로나누기, 2로나누기하는 방법 중 최소
    print(dp[X])
    ```
    
- **개미전사**
    
    식량창고에서 최대한 많은 양의 식량을 가져와야한다. 단, 선택한 식량들은 최소 한칸 이상씩 떨어져 있는 것이어야한다.
    
    <입력조건>
    
    첫째줄 : 식량창고 개수 N (3~100)
    
    둘째줄 : 각 식량 창고에 저장된 식량의 개수 (0~1,000)
    
    ```python
    N = int(input())
    K = list(map(int, input().split()))
    K[1] = max(K[0],K[1]) # dp
    for i in range(2,N):
        K[i] = max(K[i-1],K[i-2]+K[i])
        # max(전 값, 그 전의 전 값 + 내 자신)
        # 내 자신을 선택할 지, 그 전 값을 선택할지
    print(K[-1])
    ```
    
    각각 경우의 최대 식량이 dp에 저장
    
- **바닥공사**
    
    가로길이가 N 세로길이가 2인 직사각형 바닥을 1*2,2*1,2*2덮개를 이용해 채우고자한다. 바닥을 채우는 모든 경우의 수는?
    
    < 입력조건 >
    
    첫째줄 : N (1~1,000)
    
    ```python
    N = int(input())
    dp = [0]*N
    dp[0] = 1
    dp[1] = 3
    
    for i in range(2,N):
        dp[i] = dp[i-1]+dp[i-2]*2
        # i-1까지 덮개로 채워져 있는 상태에서 2*1를 추가하는 경우(i-2에 2*1 두개 포함)
        # i-2까지 덮개로 채워져 있는 상태에서 1*2로 2개 덮는 경우와 2*2 하나로 덮는 경우
    print(dp[N-1])
    ```
    
- **효율적인 화폐 구성**
    
    N가지의 화폐 종류로 그 가치의 합이 M원이 되도록하는 최소한의 화폐개수는?
    
    < 입력조건 >
    
    첫째줄 : N (1~100) M (1~10,000)
    
    둘째줄 : N개의 화폐가치 (1~10,000)
    
    ```python
    N,M = map(int,input().split())
    coins = []
    # 만드는 법이 존재하지 않는 경우 10001
    dp = [10001]*(10001)
    
    for _ in range(N):
        coins.append(int(input()))
        dp[coins[-1]] = 1
    
    start = min(coins) + 1
    
    for i in range(start,M+1):
        for j in coins:
            # i-j원을 만드는 방법이 존재하는 경우
            if i-j>0 and dp[i-j]!=10001:
                # 최소방법
                dp[i] = min(dp[i],dp[i-j]+1)
    # 최종적으로 M원을 만드는 방법이 없는 경우 -1
    if dp[M] == 10001:print(-1)
    else: print(dp[M])
    ```